# Solution to the word filter quiz
#
# Brian Schröder

module TestOptimal

OPTIMAL_FACTORS = [1.9e-06, 2.0e-06, 5.0e-06, 1.2e-05, 2.39e-05, 4.0e-05, 6.6e-05, 9.6e-05, 0.0001349, 0.000185, 0.000255, 0.0003169, 0.00041, 0.0005099, 0.0006298, 0.0007578, 0.0009129, 0.001098, 0.0012529, 0.0014739, 0.0017137, 0.001962, 0.0022419, 0.0025149, 0.0028918, 0.0031978, 0.0036277, 0.0040288, 0.0044007, 0.0048929, 0.0054687, 0.0059645, 0.0065419, 0.0071556, 0.0078399, 0.008318, 0.0089938, 0.009868, 0.0105795, 0.011416, 0.0122955, 0.013164, 0.0156628, 0.0156709, 0.0156807, 0.0166736, 0.0177158, 0.0189518, 0.0201654, 0.0215179, 0.0227469, 0.024216, 0.0255416, 0.0312682, 0.0312929, 0.0312975, 0.0313161, 0.0313346, 0.0325905, 0.0341539, 0.035902, 0.0377095, 0.0395776, 0.0416687, 0.0436688, 0.0455559, 0.0478625, 0.0625167, 0.0625536, 0.0625563, 0.0626625, 0.0626772, 0.062687, 0.062694, 0.0627154, 0.0627269, 0.0627306, 0.0627444, 0.0647637, 0.0672929, 0.0696479, 0.0725534, 0.0752868, 0.077821, 0.080686, 0.1250257, 0.1250445, 0.125047, 0.1250612, 0.1250682, 0.125074, 0.1250857, 0.1251741, 0.125177, 0.1251795, 0.1252179, 0.1252361, 0.1252443, 0.1252505, 0.1252936, 0.1252945, 0.1253048, 0.1253076, 0.1253131, 0.1253137, 0.1253236, 0.1253348, 0.1253468, 0.1253943, 0.1254086, 0.1254262, 0.1254516, 0.2500041, 0.2500171, 0.2500788, 0.2500824, 0.2500969, 0.2501145, 0.2501202, 0.2501694, 0.2502599, 0.2502737, 0.2503166, 0.2503182, 0.2503376, 0.250365, 0.2503896, 0.2504052, 0.2504233, 0.2504294, 0.2504395, 0.2505151, 0.2505691, 0.2506484, 0.2506582, 0.2506624, 0.2506648, 0.2506773, 0.2506945, 0.2507247, 0.250768, 0.250771, 0.2507888, 0.5000095, 0.5000163, 0.5000198, 0.5000229, 0.5000364, 0.5001009, 0.5001117, 0.5001151, 0.5001161, 0.5001427, 0.5001746, 0.5001843, 0.5002154, 0.5002274, 0.5002376, 0.5002449, 0.5002573, 0.5002649, 0.5002652, 0.5002711, 0.5002748, 0.5002824, 0.5003109, 0.5003364, 0.5003707, 0.5003997, 0.5004294, 0.5004377, 0.5004541, 0.5004599, 0.5004956, 0.5004958, 0.5005058, 0.5005319, 0.5005342, 0.5005579, 0.5005747, 0.5005853, 0.5006345, 0.5006611, 0.5006888, 0.5007038, 0.5007044, 0.5007174, 0.5007322, 0.5007421, 0.5007541, 0.500784, 0.5008063, 0.5008423, 0.5008515, 0.5008536, 0.5008831, 0.5009158, 0.500926, 0.5009296, 0.500931, 0.5009323, 0.5009419, 0.5009683, 0.5009687, 0.5009767, 0.5009794, 0.5010026, 0.5010167, 0.5010264, 0.5010358, 0.5010566, 0.5010747, 0.5010847, 0.5011015, 0.5011188, 0.5011408, 0.5011787, 0.5012023, 0.501225, 0.5012312, 0.5012552, 0.5012593, 0.5012615, 0.5012737, 0.5012795, 0.5012833, 0.5013367, 0.5013919, 0.501403, 0.5014046, 0.5014433, 0.5014739, 0.5014991, 0.5015136, 0.5015362, 0.5015754, 0.5017282, 0.5017374, 0.501945, 0.5022138, 0.5022517, 0.5024152, 0.5024505, 0.5025734, 0.5034851, 0.5036548, 0.5061297, 0.506671, 0.5073231, 0.5098794, 0.5101741, 0.5179837, 0.5300686, 0.5411454, 0.5449765, 0.644741]

  # Lookup optimal slice size factor for given blocked word probability
  private
  def optimal_factor(r)
    i = r ** (1.0 / 3.0) * (OPTIMAL_FACTORS.length + 1) - 1
    i = 0 if i < 0
    i = OPTIMAL_FACTORS.length - 1 if i > OPTIMAL_FACTORS.length - 1
    OPTIMAL_FACTORS[i]
  end

  public
  # Given the information which percentage of words is blocked, it should be possible to choose
  # the optimal number of slices to split the word array.
  #
  # This works, but it does not work better than the simple split always into
  # three parts approach.
  #
  # This is not consistent with my theorie, but the results are quite convincing.
  def find_words(filter, words, r = 0.01)
    return [] if words.empty? or filter.clean?(words.join(' '))
    return words if words.length == 1
    n = ([words.length.to_f * optimal_factor(r), 2.0].max).ceil
    slices = Array.new(n) { | i | i * words.length / n } << words.length
    slices[0..-2].zip(slices[1..-1]).inject([]) do | result, (low, high) | result + find_words(filter, words[low...high], r) end
  end

  extend self
end
